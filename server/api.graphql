### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Movie {
  createdAt: DateTime!
  genre: String!
  id: Int!
  title: String!
  year: Int!
}

input MovieCreateInput {
  createdAt: DateTime
  genre: String!
  Review: ReviewCreateOneWithoutMovieInput
  title: String!
  year: Int!
}

input MovieUpdateInput {
  createdAt: DateTime
  genre: String
  id: Int
  Review: ReviewUpdateOneWithoutMovieInput
  title: String
  year: Int
}

input MovieUpdateManyMutationInput {
  createdAt: DateTime
  genre: String
  id: Int
  title: String
  year: Int
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  createdAt: DateTimeFilter
  genre: StringFilter
  id: IntFilter
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  Review: ReviewWhereInput
  title: StringFilter
  year: IntFilter
}

input MovieWhereUniqueInput {
  id: Int
  year: Int
}

type Mutation {
  createMovie: Movie!
  createOneMovie(data: MovieCreateInput!): Movie!
  deleteAllMovies: String
  deleteManyMovie(where: MovieWhereInput): BatchPayload!
  deleteOneMovie(where: MovieWhereUniqueInput!): Movie
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): BatchPayload!
  updateOneMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  allMovies: [Movie!]
  drafts: [Movie!]
  movie(where: MovieWhereUniqueInput!): Movie
  movies(after: MovieWhereUniqueInput, before: MovieWhereUniqueInput, first: Int, last: Int): [Movie!]!
}

input ReviewCreateOneWithoutMovieInput {
  connect: ReviewWhereUniqueInput
  create: ReviewCreateWithoutMovieInput
}

input ReviewCreateWithoutMovieInput {
  createdAt: DateTime
  rating: Int!
  text: String
  User: UserCreateOneWithoutReviewInput!
}

input ReviewUpdateOneWithoutMovieInput {
  connect: ReviewWhereUniqueInput
  create: ReviewCreateWithoutMovieInput
  delete: Boolean
  disconnect: Boolean
  update: ReviewUpdateWithoutMovieDataInput
  upsert: ReviewUpsertWithoutMovieInput
}

input ReviewUpdateWithoutMovieDataInput {
  createdAt: DateTime
  id: Int
  rating: Int
  text: String
  User: UserUpdateOneRequiredWithoutReviewInput
}

input ReviewUpsertWithoutMovieInput {
  create: ReviewCreateWithoutMovieInput!
  update: ReviewUpdateWithoutMovieDataInput!
}

input ReviewWhereInput {
  AND: [ReviewWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  Movie: MovieWhereInput
  movieId: IntFilter
  NOT: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  rating: IntFilter
  text: NullableStringFilter
  User: UserWhereInput
  userId: IntFilter
}

input ReviewWhereUniqueInput {
  id: Int
  movieId: Int
  rating: Int
  userId: Int
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input UserCreateOneWithoutReviewInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewInput
}

input UserCreateWithoutReviewInput {
  email: String!
  username: String
}

input UserUpdateOneRequiredWithoutReviewInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewInput
  update: UserUpdateWithoutReviewDataInput
  upsert: UserUpsertWithoutReviewInput
}

input UserUpdateWithoutReviewDataInput {
  email: String
  id: Int
  username: String
}

input UserUpsertWithoutReviewInput {
  create: UserCreateWithoutReviewInput!
  update: UserUpdateWithoutReviewDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  id: IntFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Review: ReviewWhereInput
  username: NullableStringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
