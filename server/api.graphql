### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Movie {
  createdAt: DateTime!
  genre: String!
  id: Int!
  title: String!
  year: Int!
}

input MovieCreateInput {
  createdAt: DateTime
  genre: String!
  Review: ReviewCreateOneWithoutMovieInput
  title: String!
  year: Int!
}

input MovieCreateOneWithoutReviewInput {
  connect: MovieWhereUniqueInput
  create: MovieCreateWithoutReviewInput
}

input MovieCreateWithoutReviewInput {
  createdAt: DateTime
  genre: String!
  title: String!
  year: Int!
}

input MovieUpdateInput {
  createdAt: DateTime
  genre: String
  id: Int
  Review: ReviewUpdateOneWithoutMovieInput
  title: String
  year: Int
}

input MovieUpdateManyMutationInput {
  createdAt: DateTime
  genre: String
  id: Int
  title: String
  year: Int
}

input MovieUpdateOneRequiredWithoutReviewInput {
  connect: MovieWhereUniqueInput
  create: MovieCreateWithoutReviewInput
  update: MovieUpdateWithoutReviewDataInput
  upsert: MovieUpsertWithoutReviewInput
}

input MovieUpdateWithoutReviewDataInput {
  createdAt: DateTime
  genre: String
  id: Int
  title: String
  year: Int
}

input MovieUpsertWithoutReviewInput {
  create: MovieCreateWithoutReviewInput!
  update: MovieUpdateWithoutReviewDataInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  createdAt: DateTimeFilter
  genre: StringFilter
  id: IntFilter
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  Review: ReviewWhereInput
  title: StringFilter
  year: IntFilter
}

input MovieWhereUniqueInput {
  id: Int
  year: Int
}

type Mutation {
  createOneMovie(data: MovieCreateInput!): Movie!
  createOneReview(data: ReviewCreateInput!): Review!
  createOneUser(data: UserCreateInput!): User!
  deleteAllMovies: String
  deleteManyMovie(where: MovieWhereInput): BatchPayload!
  deleteManyReview(where: ReviewWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneMovie(where: MovieWhereUniqueInput!): Movie
  deleteOneReview(where: ReviewWhereUniqueInput!): Review
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): BatchPayload!
  updateManyReview(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateOneReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  allMovies: [Movie!]
  movie(where: MovieWhereUniqueInput!): Movie
  movies(after: MovieWhereUniqueInput, before: MovieWhereUniqueInput, first: Int, last: Int): [Movie!]!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(after: ReviewWhereUniqueInput, before: ReviewWhereUniqueInput, first: Int, last: Int): [Review!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

type Review {
  id: Int!
  movieId: Int!
  rating: Int!
  text: String
  userId: Int!
}

input ReviewCreateInput {
  createdAt: DateTime
  Movie: MovieCreateOneWithoutReviewInput!
  rating: Int!
  text: String
  User: UserCreateOneWithoutReviewInput!
}

input ReviewCreateOneWithoutMovieInput {
  connect: ReviewWhereUniqueInput
  create: ReviewCreateWithoutMovieInput
}

input ReviewCreateOneWithoutUserInput {
  connect: ReviewWhereUniqueInput
  create: ReviewCreateWithoutUserInput
}

input ReviewCreateWithoutMovieInput {
  createdAt: DateTime
  rating: Int!
  text: String
  User: UserCreateOneWithoutReviewInput!
}

input ReviewCreateWithoutUserInput {
  createdAt: DateTime
  Movie: MovieCreateOneWithoutReviewInput!
  rating: Int!
  text: String
}

input ReviewUpdateInput {
  createdAt: DateTime
  id: Int
  Movie: MovieUpdateOneRequiredWithoutReviewInput
  rating: Int
  text: String
  User: UserUpdateOneRequiredWithoutReviewInput
}

input ReviewUpdateManyMutationInput {
  createdAt: DateTime
  id: Int
  rating: Int
  text: String
}

input ReviewUpdateOneWithoutMovieInput {
  connect: ReviewWhereUniqueInput
  create: ReviewCreateWithoutMovieInput
  delete: Boolean
  disconnect: Boolean
  update: ReviewUpdateWithoutMovieDataInput
  upsert: ReviewUpsertWithoutMovieInput
}

input ReviewUpdateOneWithoutUserInput {
  connect: ReviewWhereUniqueInput
  create: ReviewCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: ReviewUpdateWithoutUserDataInput
  upsert: ReviewUpsertWithoutUserInput
}

input ReviewUpdateWithoutMovieDataInput {
  createdAt: DateTime
  id: Int
  rating: Int
  text: String
  User: UserUpdateOneRequiredWithoutReviewInput
}

input ReviewUpdateWithoutUserDataInput {
  createdAt: DateTime
  id: Int
  Movie: MovieUpdateOneRequiredWithoutReviewInput
  rating: Int
  text: String
}

input ReviewUpsertWithoutMovieInput {
  create: ReviewCreateWithoutMovieInput!
  update: ReviewUpdateWithoutMovieDataInput!
}

input ReviewUpsertWithoutUserInput {
  create: ReviewCreateWithoutUserInput!
  update: ReviewUpdateWithoutUserDataInput!
}

input ReviewWhereInput {
  AND: [ReviewWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  Movie: MovieWhereInput
  movieId: IntFilter
  NOT: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  rating: IntFilter
  text: NullableStringFilter
  User: UserWhereInput
  userId: IntFilter
}

input ReviewWhereUniqueInput {
  id: Int
  movieId: Int
  rating: Int
  userId: Int
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  email: String!
  id: Int!
  username: String
}

input UserCreateInput {
  email: String!
  Review: ReviewCreateOneWithoutUserInput
  username: String
}

input UserCreateOneWithoutReviewInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewInput
}

input UserCreateWithoutReviewInput {
  email: String!
  username: String
}

input UserUpdateInput {
  email: String
  id: Int
  Review: ReviewUpdateOneWithoutUserInput
  username: String
}

input UserUpdateManyMutationInput {
  email: String
  id: Int
  username: String
}

input UserUpdateOneRequiredWithoutReviewInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewInput
  update: UserUpdateWithoutReviewDataInput
  upsert: UserUpsertWithoutReviewInput
}

input UserUpdateWithoutReviewDataInput {
  email: String
  id: Int
  username: String
}

input UserUpsertWithoutReviewInput {
  create: UserCreateWithoutReviewInput!
  update: UserUpdateWithoutReviewDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  id: IntFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Review: ReviewWhereInput
  username: NullableStringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
