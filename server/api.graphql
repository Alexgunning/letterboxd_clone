### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Movie {
  createdAt: DateTime!
  genre: String!
  id: Int!
  image_url: String
  rating: Float
  Review(after: ReviewWhereUniqueInput, before: ReviewWhereUniqueInput, first: Int, last: Int): [Review!]!
  summary: String
  title: String!
  url: String
  year: Int!
}

input MovieCreateInput {
  createdAt: DateTime
  genre: String!
  image_url: String
  Review: ReviewCreateManyWithoutMovieInput
  summary: String
  title: String!
  url: String
  year: Int!
}

input MovieCreateOneWithoutReviewInput {
  connect: MovieWhereUniqueInput
  create: MovieCreateWithoutReviewInput
}

input MovieCreateWithoutReviewInput {
  createdAt: DateTime
  genre: String!
  image_url: String
  summary: String
  title: String!
  url: String
  year: Int!
}

input MovieOrderByInput {
  createdAt: OrderByArg
  genre: OrderByArg
  id: OrderByArg
  image_url: OrderByArg
  summary: OrderByArg
  title: OrderByArg
  url: OrderByArg
  year: OrderByArg
}

input MovieUpdateInput {
  createdAt: DateTime
  genre: String
  id: Int
  image_url: String
  Review: ReviewUpdateManyWithoutMovieInput
  summary: String
  title: String
  url: String
  year: Int
}

input MovieUpdateManyMutationInput {
  createdAt: DateTime
  genre: String
  id: Int
  image_url: String
  summary: String
  title: String
  url: String
  year: Int
}

input MovieUpdateOneRequiredWithoutReviewInput {
  connect: MovieWhereUniqueInput
  create: MovieCreateWithoutReviewInput
  update: MovieUpdateWithoutReviewDataInput
  upsert: MovieUpsertWithoutReviewInput
}

input MovieUpdateWithoutReviewDataInput {
  createdAt: DateTime
  genre: String
  id: Int
  image_url: String
  summary: String
  title: String
  url: String
  year: Int
}

input MovieUpsertWithoutReviewInput {
  create: MovieCreateWithoutReviewInput!
  update: MovieUpdateWithoutReviewDataInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  createdAt: DateTimeFilter
  genre: StringFilter
  id: IntFilter
  image_url: NullableStringFilter
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  Review: ReviewFilter
  summary: NullableStringFilter
  title: StringFilter
  url: NullableStringFilter
  year: IntFilter
}

input MovieWhereUniqueInput {
  id: Int
}

type Mutation {
  createMovie(genre: String!, image_url: String!, summary: String!, title: String!, year: Int!): Movie
  createOneMovie(data: MovieCreateInput!): Movie!
  createOneReview(data: ReviewCreateInput!): Review!
  createOneUser(data: UserCreateInput!): User!
  createReview(movieId: Int!, rating: Int!, text: String!, userId: Int!): Review
  deleteManyMovie(where: MovieWhereInput): BatchPayload!
  deleteManyReview(where: ReviewWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneMovie(where: MovieWhereUniqueInput!): Movie
  deleteOneReview(where: ReviewWhereUniqueInput!): Review
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): BatchPayload!
  updateManyReview(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateOneReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  allMovies: [Movie!]
  movie(where: MovieWhereUniqueInput!): Movie
  movies(after: MovieWhereUniqueInput, before: MovieWhereUniqueInput, first: Int, last: Int, orderBy: MovieOrderByInput, where: MovieWhereInput): [Movie!]!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(after: ReviewWhereUniqueInput, before: ReviewWhereUniqueInput, first: Int, last: Int, orderBy: ReviewOrderByInput, where: ReviewWhereInput): [Review!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

type Review {
  id: Int!
  Movie: Movie!
  rating: Int!
  text: String
  User: User!
}

input ReviewCreateInput {
  createdAt: DateTime
  Movie: MovieCreateOneWithoutReviewInput!
  rating: Int!
  text: String
  User: UserCreateOneWithoutReviewInput!
}

input ReviewCreateManyWithoutMovieInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutMovieInput!]
}

input ReviewCreateManyWithoutUserInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutUserInput!]
}

input ReviewCreateWithoutMovieInput {
  createdAt: DateTime
  rating: Int!
  text: String
  User: UserCreateOneWithoutReviewInput!
}

input ReviewCreateWithoutUserInput {
  createdAt: DateTime
  Movie: MovieCreateOneWithoutReviewInput!
  rating: Int!
  text: String
}

input ReviewFilter {
  every: ReviewWhereInput
  none: ReviewWhereInput
  some: ReviewWhereInput
}

input ReviewOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  movieId: OrderByArg
  rating: OrderByArg
  text: OrderByArg
  userId: OrderByArg
}

input ReviewScalarWhereInput {
  AND: [ReviewScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  movieId: IntFilter
  NOT: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  rating: IntFilter
  text: NullableStringFilter
  userId: IntFilter
}

input ReviewUpdateInput {
  createdAt: DateTime
  id: Int
  Movie: MovieUpdateOneRequiredWithoutReviewInput
  rating: Int
  text: String
  User: UserUpdateOneRequiredWithoutReviewInput
}

input ReviewUpdateManyDataInput {
  createdAt: DateTime
  id: Int
  rating: Int
  text: String
}

input ReviewUpdateManyMutationInput {
  createdAt: DateTime
  id: Int
  rating: Int
  text: String
}

input ReviewUpdateManyWithoutMovieInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutMovieInput!]
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutMovieInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutMovieInput!]
}

input ReviewUpdateManyWithoutUserInput {
  connect: [ReviewWhereUniqueInput!]
  create: [ReviewCreateWithoutUserInput!]
  delete: [ReviewWhereUniqueInput!]
  deleteMany: [ReviewScalarWhereInput!]
  disconnect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutUserInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  data: ReviewUpdateManyDataInput!
  where: ReviewScalarWhereInput!
}

input ReviewUpdateWithoutMovieDataInput {
  createdAt: DateTime
  id: Int
  rating: Int
  text: String
  User: UserUpdateOneRequiredWithoutReviewInput
}

input ReviewUpdateWithoutUserDataInput {
  createdAt: DateTime
  id: Int
  Movie: MovieUpdateOneRequiredWithoutReviewInput
  rating: Int
  text: String
}

input ReviewUpdateWithWhereUniqueWithoutMovieInput {
  data: ReviewUpdateWithoutMovieDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpdateWithWhereUniqueWithoutUserInput {
  data: ReviewUpdateWithoutUserDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithWhereUniqueWithoutMovieInput {
  create: ReviewCreateWithoutMovieInput!
  update: ReviewUpdateWithoutMovieDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewUpsertWithWhereUniqueWithoutUserInput {
  create: ReviewCreateWithoutUserInput!
  update: ReviewUpdateWithoutUserDataInput!
  where: ReviewWhereUniqueInput!
}

input ReviewWhereInput {
  AND: [ReviewWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  Movie: MovieWhereInput
  movieId: IntFilter
  NOT: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  rating: IntFilter
  text: NullableStringFilter
  User: UserWhereInput
  userId: IntFilter
}

input ReviewWhereUniqueInput {
  id: Int
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  email: String!
  id: Int!
  Review(after: ReviewWhereUniqueInput, before: ReviewWhereUniqueInput, first: Int, last: Int): [Review!]!
  username: String
}

input UserCreateInput {
  email: String!
  Review: ReviewCreateManyWithoutUserInput
  username: String
}

input UserCreateOneWithoutReviewInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewInput
}

input UserCreateWithoutReviewInput {
  email: String!
  username: String
}

input UserUpdateInput {
  email: String
  id: Int
  Review: ReviewUpdateManyWithoutUserInput
  username: String
}

input UserUpdateManyMutationInput {
  email: String
  id: Int
  username: String
}

input UserUpdateOneRequiredWithoutReviewInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutReviewInput
  update: UserUpdateWithoutReviewDataInput
  upsert: UserUpsertWithoutReviewInput
}

input UserUpdateWithoutReviewDataInput {
  email: String
  id: Int
  username: String
}

input UserUpsertWithoutReviewInput {
  create: UserCreateWithoutReviewInput!
  update: UserUpdateWithoutReviewDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  id: IntFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Review: ReviewFilter
  username: NullableStringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
