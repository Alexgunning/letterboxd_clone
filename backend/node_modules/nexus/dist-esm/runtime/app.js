import * as Logger from '@nexus/logger';
import { rootLogger } from '../lib/nexus-logger';
import * as Plugin from '../lib/plugin';
import * as Reflection from '../lib/reflection/stage';
import * as Schema from './schema';
import * as Server from './server';
import * as Settings from './settings';
import { assertAppNotAssembled } from './utils';
import { builtinScalars } from '../lib/scalars';
const log = Logger.log.child('app');
/**
 * Create new app state. Be careful to pass this state to components to complete its
 * data. The data returned only contains core state, despite what the return
 * type says.
 */
export function createAppState() {
    const appState = {
        assembled: null,
        running: false,
        plugins: [],
    };
    return appState;
}
/**
 * Create an app instance
 */
export function create() {
    const appState = createAppState();
    const serverComponent = Server.create(appState);
    const schemaComponent = Schema.create(appState);
    const settingsComponent = Settings.create(appState, {
        serverSettings: serverComponent.private.settings,
        schemaSettings: schemaComponent.private.settings,
        log: Logger.log,
    });
    const app = {
        log: log,
        settings: settingsComponent.public,
        schema: schemaComponent.public,
        server: serverComponent.public,
        reset() {
            // todo once we have log filtering, make this debug level
            rootLogger.trace('resetting state');
            schemaComponent.private.reset();
            serverComponent.private.reset();
            settingsComponent.private.reset();
            appState.assembled = null;
            appState.plugins = [];
            appState.running = false;
        },
        assemble() {
            if (appState.assembled)
                return;
            schemaComponent.private.beforeAssembly();
            /**
             * Plugin reflection is run in the same process (eval). This means if the
             * process is the app, which it is during testing for example, then we
             * need to take extreme care to not mark assembly as complete, during
             * plugin reflection. If we did, then, when we would try to start the app,
             * it would think it is already assembled. !
             */
            if (Reflection.isReflectionStage('plugin'))
                return;
            appState.assembled = {};
            const loadedPlugins = Plugin.importAndLoadRuntimePlugins(appState.plugins, appState.schemaComponent.scalars);
            appState.assembled.loadedPlugins = loadedPlugins;
            const { schema, missingTypes } = schemaComponent.private.assemble(loadedPlugins);
            appState.assembled.schema = schema;
            appState.assembled.missingTypes = missingTypes;
            if (Reflection.isReflectionStage('typegen'))
                return;
            const { createContext } = serverComponent.private.assemble(loadedPlugins, schema);
            appState.assembled.createContext = createContext;
            const { settings } = settingsComponent.private.assemble();
            appState.assembled.settings = settings;
            schemaComponent.private.checks();
        },
        async start() {
            if (Reflection.isReflection())
                return;
            if (appState.running)
                return;
            await serverComponent.private.start();
            appState.running = true;
        },
        async stop() {
            if (Reflection.isReflection())
                return;
            if (!appState.running)
                return;
            await serverComponent.private.stop();
            appState.running = false;
        },
        use(plugin) {
            assertAppNotAssembled(appState, 'app.use', 'The plugin you attempted to use will be ignored');
            appState.plugins.push(plugin);
        },
    };
    /**
     * Setup default log filter
     */
    app.settings.change({
        logger: {
            filter: 'app:*, nexus:*@info+, *@warn+',
        },
    });
    /**
     * Setup default scalar types
     */
    app.schema.importType(builtinScalars.DateTime, 'date');
    app.schema.importType(builtinScalars.Json, 'json');
    return Object.assign(Object.assign({}, app), { private: {
            state: appState,
        } });
}
//# sourceMappingURL=app.js.map