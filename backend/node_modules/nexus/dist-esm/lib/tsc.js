import { left, right } from 'fp-ts/lib/Either';
import * as fs from 'fs-jetpack';
import { addHook } from 'pirates';
import * as ts from 'typescript';
import { rootLogger } from './nexus-logger';
import { exception } from './utils';
const log = rootLogger.child('tsc');
/**
 * Create a TypeScript program.
 */
export function createTSProgram(layout, options) {
    // Incremental option cannot be set when `noEmit: true`
    const compilerCacheOptions = (options === null || options === void 0 ? void 0 : options.withCache) && !layout.tsConfig.content.options.noEmit
        ? {
            tsBuildInfoFile: getTSIncrementalFilePath(layout),
            incremental: true,
        }
        : {};
    log.trace('Create TypeScript program');
    const builder = ts.createIncrementalProgram({
        rootNames: layout.nexusModules.concat(layout.app.exists ? [layout.app.path] : []),
        options: Object.assign(Object.assign(Object.assign({}, compilerCacheOptions), layout.tsConfig.content.options), { outDir: layout.build.tsOutputDir }),
    });
    // If the program has imports to modules outside the source root then TS out root will be forced
    // into an unexpected layout, and consequently the start module imports will fail. Check for this
    // specific kind of error now. All other error checking will be deferred until after typegen has been run however.
    // todo testme
    const SOURCE_ROOT_MUST_CONTAIN_ALL_SOURCE_FILES_ERROR_CODE = 6059;
    const errors = ts.getPreEmitDiagnostics(builder.getProgram());
    const maybeSourceRootMustContainAllSourceFilesError = errors.find((error) => error.code === SOURCE_ROOT_MUST_CONTAIN_ALL_SOURCE_FILES_ERROR_CODE);
    if (maybeSourceRootMustContainAllSourceFilesError) {
        const message = 'Your app is invalid\n\n' +
            ts.formatDiagnosticsWithColorAndContext([maybeSourceRootMustContainAllSourceFilesError], diagnosticHost);
        return left(exception(message));
    }
    return right(builder);
}
export function deleteTSIncrementalFile(layout) {
    fs.remove(getTSIncrementalFilePath(layout));
}
export function getTSIncrementalFilePath(layout) {
    return layout.projectPath('node_modules', '.nexus', 'cache.tsbuildinfo');
}
/**
 * compile a program. Throws an error if the program does not type check.
 */
export function emitTSProgram(builder, layout, options) {
    var _a, _b;
    if ((options === null || options === void 0 ? void 0 : options.removePreviousBuild) === true) {
        log.trace('remove previous build folder if present');
        fs.remove(layout.build.tsOutputDir);
    }
    log.trace('emit transpiled modules', { dest: layout.build.tsOutputDir });
    const emitResult = builder.emit();
    log.trace('done', { filesEmitted: (_b = (_a = emitResult.emittedFiles) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0 });
    if ((options === null || options === void 0 ? void 0 : options.skipTSErrors) === true) {
        return;
    }
    const allDiagnostics = ts.getPreEmitDiagnostics(builder.getProgram()).concat(emitResult.diagnostics);
    if (allDiagnostics.length > 0) {
        throw new Error(ts.formatDiagnosticsWithColorAndContext(allDiagnostics, diagnosticHost));
    }
}
/**
 * Transpile a TS module to JS.
 */
export function transpileModule(input, compilerOptions) {
    // todo use layout and get tsconfig settings from there?
    return ts.transpileModule(input, { compilerOptions }).outputText;
}
const diagnosticHost = {
    getNewLine: () => ts.sys.newLine,
    getCurrentDirectory: () => process.cwd(),
    getCanonicalFileName: (path) => path,
};
class TSError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        // Make sure `name` property is not enumerable
        // so that it doesn't end up in console.log
        Object.defineProperty(this, 'name', {
            value: 'TSError',
            enumerable: false,
        });
    }
}
function createTSError(diagnostics) {
    const diagnosticText = ts.formatDiagnosticsWithColorAndContext(diagnostics, diagnosticHost);
    return new TSError(`тип Unable to compile TypeScript:\n${diagnosticText}`);
}
/**
 * Allow node to require TypeScript modules, transpiling them on the fly.
 *
 * @remarks
 *
 * This is strictly about transpilation, no type checking is done.
 */
export function registerTypeScriptTranspile(compilerOptions) {
    addHook((source, fileName) => {
        const transpiled = ts.transpileModule(source, {
            reportDiagnostics: true,
            fileName,
            compilerOptions,
        });
        if (transpiled.diagnostics && transpiled.diagnostics.length > 0) {
            throw createTSError(transpiled.diagnostics);
        }
        return transpiled.outputText;
    }, { exts: ['.ts'] });
}
//# sourceMappingURL=tsc.js.map