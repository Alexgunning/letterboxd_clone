"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.relativeTranspiledImportPath = exports.printStaticImports = exports.prepareStartModule = exports.createStartModuleContent = exports.START_MODULE_HEADER = exports.START_MODULE_NAME = void 0;
const tslib_1 = require("tslib");
const common_tags_1 = require("common-tags");
const os_1 = require("os");
const Path = tslib_1.__importStar(require("path"));
const fs_1 = require("../../lib/fs");
const nexus_logger_1 = require("../../lib/nexus-logger");
const tsc_1 = require("../../lib/tsc");
const resolve_from_1 = require("./resolve-from");
const log = nexus_logger_1.rootLogger.child('startModule');
exports.START_MODULE_NAME = 'index';
exports.START_MODULE_HEADER = 'GENERATED NEXUS START MODULE';
function createStartModuleContent(config) {
    let content = `// ${exports.START_MODULE_HEADER}`;
    if (config.registerTypeScript) {
        content += os_1.EOL + os_1.EOL + os_1.EOL;
        content += common_tags_1.stripIndent `
      import { registerTypeScriptTranspile } from '${config.absoluteModuleImports
            ? Path.dirname(resolve_from_1.resolveFrom('nexus', config.layout.projectRoot))
            : 'nexus/dist'}/lib/tsc'
      registerTypeScriptTranspile(${typeof config.registerTypeScript === 'object' ? JSON.stringify(config.registerTypeScript) : '{}'})
    `;
    }
    if (config.internalStage === 'dev') {
        content += os_1.EOL + os_1.EOL + os_1.EOL;
        content += common_tags_1.stripIndent `
      process.env.NEXUS_STAGE = 'dev'
    `;
    }
    content += os_1.EOL + os_1.EOL + os_1.EOL;
    content += common_tags_1.stripIndent `
    // Run framework initialization side-effects
    // Also, import the app for later use
    import app from "${config.absoluteModuleImports ? resolve_from_1.resolveFrom('nexus', config.layout.projectRoot) : 'nexus'}")
  `;
    if (config.catchUnhandledErrors !== false) {
        // todo test coverage for this feature
        content += os_1.EOL + os_1.EOL + os_1.EOL;
        content += common_tags_1.stripIndent `
    // Last resort error handling
    process.once('uncaughtException', error => {
      app.log.fatal('uncaughtException', { error: error })
      process.exit(1)
    })

    process.once('unhandledRejection', error => {
      app.log.fatal('unhandledRejection', { error: error })
      process.exit(1)
    })
  `;
    }
    // This MUST come after nexus package has been imported for its side-effects
    const staticImports = printStaticImports(config.layout, {
        absolutePaths: config.absoluteModuleImports,
    });
    if (staticImports !== '') {
        content += os_1.EOL + os_1.EOL + os_1.EOL;
        content += common_tags_1.stripIndent `
        // Import the user's schema modules
        ${staticImports}
      `;
    }
    if (config.layout.app.exists) {
        content += os_1.EOL + os_1.EOL + os_1.EOL;
        content += common_tags_1.stripIndent `
      // Import the user's app module
      require("${config.absoluteModuleImports
            ? fs_1.stripExt(config.layout.app.path)
            : './' + fs_1.stripExt(config.layout.sourceRelative(config.layout.app.path))}")
    `;
    }
    if (config.runtimePluginManifests.length) {
        content += os_1.EOL + os_1.EOL + os_1.EOL;
        content += common_tags_1.stripIndent `
      ${config.runtimePluginManifests
            .map((plugin, i) => {
            return `import { ${plugin.runtime.export} as plugin_${i} } from '${config.absoluteModuleImports
                ? plugin.runtime.module
                : relativeModuleImport(plugin.name, plugin.runtime.module)}'`;
        })
            .join(os_1.EOL)}
    `;
    }
    content += os_1.EOL + os_1.EOL + os_1.EOL;
    content += common_tags_1.stripIndent `
    app.assemble()
    app.start()
  `;
    log.trace('created start module', { content });
    return content;
}
exports.createStartModuleContent = createStartModuleContent;
function prepareStartModule(tsBuilder, startModule) {
    log.trace('Transpiling start module');
    return tsc_1.transpileModule(startModule, tsBuilder.getCompilerOptions());
}
exports.prepareStartModule = prepareStartModule;
/**
 * Build up static import code for all schema modules in the project. The static
 * imports are relative so that they can be calculated based on source layout
 * but used in build layout.
 *
 * Note that it is assumed the module these imports will run in will be located
 * in the source/build root.
 */
function printStaticImports(layout, opts) {
    return layout.nexusModules.reduce((script, modulePath) => {
        const path = (opts === null || opts === void 0 ? void 0 : opts.absolutePaths) ? fs_1.stripExt(modulePath) : relativeTranspiledImportPath(layout, modulePath);
        return `${script}\n${printSideEffectsImport(path)}`;
    }, '');
}
exports.printStaticImports = printStaticImports;
function printSideEffectsImport(modulePath) {
    return `import '${modulePath}'`;
}
/**
 * Build up what the import path will be for a module in its transpiled context.
 */
function relativeTranspiledImportPath(layout, modulePath) {
    return './' + fs_1.stripExt(calcSourceRootToModule(layout, modulePath));
}
exports.relativeTranspiledImportPath = relativeTranspiledImportPath;
function calcSourceRootToModule(layout, modulePath) {
    return Path.relative(layout.sourceRoot, modulePath);
}
function relativeModuleImport(moduleName, absoluteModuleImport) {
    const moduleNamePos = absoluteModuleImport.lastIndexOf(moduleName);
    const relativeModuleImport = absoluteModuleImport.substring(moduleNamePos);
    return fs_1.stripExt(relativeModuleImport);
}
//# sourceMappingURL=start-module.js.map