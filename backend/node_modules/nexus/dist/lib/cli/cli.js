"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CLI = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nexus_logger_1 = require("../nexus-logger");
const help_1 = require("./help");
const helpers_1 = require("./helpers");
const version_1 = require("./version");
function createCommandRef(value, parent) {
    const referencedCommand = parent.value[value];
    if (referencedCommand === undefined) {
        throw new Error(`Unable to deref "${value}" on ${parent}`);
    }
    if (referencedCommand.type !== 'concrete_command') {
        throw new Error(`References must point to a concrete command. The ref "${value}" actually pointed to ${referencedCommand}.`);
    }
    return {
        type: 'command_reference',
        value: {
            original: value,
            commandPointer: referencedCommand,
        },
        parent,
    };
}
function createConcreteCommand(value, parent) {
    return { type: 'concrete_command', value, parent };
}
function createCommandNamespace(value, parent) {
    return { type: 'command_namespace', value, parent };
}
function buildCommandsTree(cmds) {
    return buildCommandsSubTree(cmds, null);
}
function buildCommandsSubTree(cmds, parent) {
    const branch = createCommandNamespace({}, parent);
    for (const [name, cmd] of Object.entries(cmds)) {
        branch.value[name] = buildCommandsEntry(cmd, branch);
    }
    return branch;
}
function buildCommandsEntry(cmd, parent) {
    if (typeof cmd === 'string') {
        // TODO need concept of createUnresolvedCommandRef because de-referring
        // needs to come after the tree of concrete command values has been built.
        // Easy workaround for now is to keep all reference nodes at the bottom of
        // their respective namespace...!
        return createCommandRef(cmd, parent);
    }
    else if (typeof cmd.parse === 'function') {
        return createConcreteCommand(cmd, parent);
    }
    else if (typeof cmd === 'object') {
        return buildCommandsSubTree(cmd, parent);
    }
    else {
        throw new Error(`Could not process given commands layout entry: ${cmd}`);
    }
}
/**
 * Helper function for looking up a command by name on a command namespace that
 * correctly types the possibility of lookup failing.
 */
function lookupCommand(name, namespace) {
    return namespace.value[name];
}
function isFlag(arg) {
    return arg && (arg.startsWith('-') || arg.startsWith('--'));
}
/**
 * CLI command
 */
let CLI = /** @class */ (() => {
    class CLI {
        constructor(cmds) {
            this.cmds = cmds;
        }
        // TODO setup stop at positional option, have each sub-command parse in turn
        // https://github.com/zeit/arg#stopatpositional
        async parse(argv) {
            const args = helpers_1.arg(argv, {
                '--help': Boolean,
                '-h': '--help',
                '--version': Boolean,
                '-v': '--version',
            });
            if (helpers_1.isError(args)) {
                return this.help(args.message);
            }
            if (args['--version']) {
                return version_1.Version.new().parse(argv);
            }
            if (args['--help']) {
                return this.help();
            }
            // parse the invocation path
            let targettedCommand = buildCommandsTree(this.cmds);
            while (true) {
                if (targettedCommand.type !== 'command_namespace')
                    break;
                const nextArg = args._.shift();
                if (nextArg === undefined)
                    break;
                // If it's a flag, enqueue back the flag and break
                if (isFlag(nextArg)) {
                    args._ = [nextArg, ...args._];
                    break;
                }
                const nextCommandNode = lookupCommand(nextArg, targettedCommand);
                if (nextCommandNode === undefined) {
                    return help_1.unknownCommand(CLI.help, nextArg);
                }
                targettedCommand = nextCommandNode;
            }
            // Check if
            for (const nextArg of args._) {
                if (targettedCommand.type !== 'command_namespace')
                    break;
                if (nextArg === undefined)
                    break;
                if (lookupCommand(nextArg, targettedCommand)) {
                    nexus_logger_1.log.fatal('Flags always needs to be in the last position');
                    process.exit(1);
                }
            }
            // Resolve the runner
            let run = null;
            switch (targettedCommand.type) {
                case 'concrete_command':
                    run = targettedCommand.value.parse.bind(targettedCommand.value);
                    break;
                case 'command_reference':
                    run = targettedCommand.value.commandPointer.value.parse.bind(targettedCommand.value.commandPointer.value);
                    break;
                case 'command_namespace':
                    const nsDefault = lookupCommand('__default', targettedCommand);
                    // When no sub-command given display help or the default sub-command if
                    // registered
                    if (nsDefault === undefined) {
                        // TODO should return command help, rather than assuming root help
                        return this.help();
                    }
                    else if (nsDefault.type === 'concrete_command') {
                        run = nsDefault.value.parse.bind(nsDefault.value);
                    }
                    else if (nsDefault.type === 'command_reference') {
                        run = nsDefault.value.commandPointer.value.parse.bind(nsDefault.value.commandPointer.value);
                    }
                    else {
                        throw new Error(`Attempt to run namespace default failed because was not a command or reference to a command. Was: ${nsDefault}`);
                    }
            }
            return run(args._).catch((e) => e); // treat error like Either type
        }
        // help function
        help(error) {
            if (error) {
                return new help_1.HelpError(`\n${chalk_1.default.bold.red(`!`)} ${error}\n${CLI.help}`);
            }
            return CLI.help;
        }
    }
    // TODO generate this from cli tree
    // static help template
    CLI.help = helpers_1.format(`
    Delightful GraphQL Application Framework - https://nexusjs.org

    ${chalk_1.default.bold('Usage')}

      ${chalk_1.default.dim(`$`)} nexus [command]

    ${chalk_1.default.bold('Commands')}

        create   Setup a ready-to-use nexus
           dev   Develop your application in watch mode
         build   Build a production-ready server

    ${chalk_1.default.bold('Examples')}

      Initialize files for a new nexus project
      ${chalk_1.default.dim(`$`)} nexus create

      Start developing and watch your changes locally
      ${chalk_1.default.dim(`$`)} nexus dev

      Build a production-ready server
      ${chalk_1.default.dim(`$`)} nexus build
  `);
    return CLI;
})();
exports.CLI = CLI;
//# sourceMappingURL=cli.js.map