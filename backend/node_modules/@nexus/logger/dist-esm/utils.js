import { isLeft, isRight } from 'fp-ts/lib/Either';
import { format } from 'util';
/**
 * Guarantee the length of a given string, padding before or after with the
 * given character. If the given string is longer than  the span target, then it
 * will be cropped.
 */
export function span(padSide, padChar, target, content) {
    if (content.length > target) {
        return content.slice(0, target);
    }
    let toPadSize = target - content.length;
    while (toPadSize > 0) {
        if (padSide === 'padAfter') {
            content = content + padChar;
        }
        else if (padSide === 'padBefore') {
            content = padChar + content;
        }
        toPadSize--;
    }
    return content;
}
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned left and if exceeds span target length to begin with gets cropped.
 */
export const clampSpace = span.bind(null, 'padAfter', ' ');
/**
 * Create a string of space of the given length.
 */
export function spanSpace(num) {
    return spanChar(num, ' ');
}
/**
 * Create a string of the given length and character
 */
export function spanChar(num, char) {
    return range(num).map(constant(char)).join('');
}
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned right and if exceeds span target length to begin with gets cropped.
 */
export const spanSpaceRight = span.bind(null, 'padBefore', ' ');
/**
 * Use this to make assertion at end of if-else chain that all members of a
 * union have been accounted for.
 */
export function casesHandled(x) {
    throw new Error(`A case of value was not handled: ${x}`);
}
/**
 * Create a function that will only ever return the given value when called.
 */
export function constant(x) {
    return function () {
        return x;
    };
}
/**
 * Create a range of integers.
 */
export function range(times) {
    const list = [];
    while (list.length < times) {
        list.push(list.length + 1);
    }
    return list;
}
/**
 * Strip keys from object whose value is undefined.
 */
export function omitUndefinedKeys(data) {
    return Object.entries(data !== null && data !== void 0 ? data : {})
        .filter(([k, v]) => v !== undefined)
        .reduce((acc, [k, v]) => Object.assign(acc, { [k]: v }), {});
}
/**
 * Get the last item of an array.
 */
export function last(xs) {
    return xs[xs.length - 1];
}
export function isEmpty(x) {
    if (typeof x === 'string' && x === '')
        return true;
    if (x === undefined)
        return true;
    return Object.values(x).filter((val) => val !== undefined).length === 0;
}
/**
 * Run a given parser over an environment variable. If parsing fails, throw a
 * contextual error message.
 */
export function parseFromEnvironment(key, parser) {
    const envVarValue = process.env[key]; // assumes env presence handled before
    const result = parser.run(envVarValue);
    if (result === null) {
        throw new Error(`Could not parse environment variable ${key} into ${parser.info.typeName}. The environment variable was: ${format(envVarValue)}. A valid environment variable must be like: ${parser.info.valid}`);
    }
    return result;
}
/**
 * Create an error with contextual data about it.
 *
 * @remarks
 *
 * This is handy with fp-ts Either<...> because, unlike try-catch, errors are
 * strongly typed with the Either contstruct, making it so the error contextual
 * data flows with inference through your program.
 */
export function createContextualError(message, context) {
    const e = new Error(message);
    Object.defineProperty(e, 'message', {
        enumerable: true,
        value: e.message,
    });
    e.context = context;
    return e;
}
/**
 * Extract the left value from an Either.
 */
export function getLeft(e) {
    if (isLeft(e))
        return e.left;
    return undefined;
}
/**
 * Extract the right value from an Either.
 */
export function getRight(e) {
    if (isRight(e))
        return e.right;
    return undefined;
}
/**
 * Extract the right value from an Either or throw.
 */
export function rightOrThrow(x) {
    if (isLeft(x))
        throw new Error(`Failed to get right value of either type because it was actually left. The left value was:\n\n${x.left}`);
    return x.right;
}
//# sourceMappingURL=utils.js.map