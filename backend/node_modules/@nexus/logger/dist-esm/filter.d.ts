import { Either } from 'fp-ts/lib/Either';
import * as Level from './level';
import type { LogRecord } from './logger';
import { ContextualError } from './utils';
export declare type Parsed = {
    originalInput: string;
    level: {
        value: Level.Name | '*';
        comp: 'lte' | 'gte' | 'eq';
    };
    negate: boolean;
    path: {
        value: string;
        descendants: false | {
            includeParent: boolean;
        };
    };
};
/**
 * Some of the criteria a pattern can specify are optional. When such criteria
 * are not specified, then these defaults are used.
 */
export declare type Defaults = {
    level: {
        value: Level.Name;
        comp: Parsed['level']['comp'];
    };
};
/**
 * Parse a full pattern. This accounts for lists of patterns. This is the parsing entrypoint.
 */
export declare function parse(defaults: Defaults, pattern: string): Either<ParseError, Parsed>[];
/**
 * Parse a single pattern. This assumes parsing of "," has already been handled
 * including whitespace trimming around the pattern.
 */
export declare function parseOne(criteriaDefaults: Defaults, pattern: string): Either<ParseError, Parsed>;
/**
 * Test if a log matches the pattern.
 */
export declare function test(patterns: Readonly<Parsed[]>, log: LogRecord): boolean;
/**
 * Like `parse` but throws upon any failure.
 *
 * @remarks
 *
 * Only use this if you know what you're doing.
 */
export declare function parseUnsafe(defaults: Defaults, pattern: string): Parsed[];
declare type ParseError = ContextualError<{
    pattern: string;
    hint?: string;
}>;
/**
 * Get the string contents of a manual showing how to write filters.
 */
export declare function renderSyntaxManual(): string;
export declare function renderSyntaxError(input: {
    errPatterns: Either<ParseError, Parsed>[];
    foundIn?: string;
    some?: boolean;
}): string;
export declare function processLogFilterInput(defaults: Defaults, pattern: string, foundIn?: string): null | Parsed[];
export {};
//# sourceMappingURL=filter.d.ts.map