import { Either } from 'fp-ts/lib/Either';
/**
 * Guarantee the length of a given string, padding before or after with the
 * given character. If the given string is longer than  the span target, then it
 * will be cropped.
 */
export declare function span(padSide: 'padBefore' | 'padAfter', padChar: string, target: number, content: string): string;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned left and if exceeds span target length to begin with gets cropped.
 */
export declare const clampSpace: (target: number, content: string) => string;
/**
 * Create a string of space of the given length.
 */
export declare function spanSpace(num: number): string;
/**
 * Create a string of the given length and character
 */
export declare function spanChar(num: number, char: string): string;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned right and if exceeds span target length to begin with gets cropped.
 */
export declare const spanSpaceRight: (target: number, content: string) => string;
/**
 * Use this to make assertion at end of if-else chain that all members of a
 * union have been accounted for.
 */
export declare function casesHandled(x: never): never;
/**
 * Create a function that will only ever return the given value when called.
 */
export declare function constant<T>(x: T): () => T;
/**
 * Create a range of integers.
 */
export declare function range(times: number): number[];
/**
 * Strip keys from object whose value is undefined.
 */
export declare function omitUndefinedKeys<T extends Record<string, unknown>>(data: T): T;
/**
 * Get the last item of an array.
 */
export declare function last<T>(xs: T[]): T;
export declare function isEmpty(x?: object | string): boolean;
/**
 * Run a given parser over an environment variable. If parsing fails, throw a
 * contextual error message.
 */
export declare function parseFromEnvironment<T>(key: string, parser: {
    info: {
        valid: string;
        typeName: string;
    };
    run: (raw: string) => null | T;
}): T;
/**
 * An error with additional contextual data.
 */
export declare type ContextualError<Context extends Record<string, unknown> = {}> = Error & {
    context: Context;
};
/**
 * Create an error with contextual data about it.
 *
 * @remarks
 *
 * This is handy with fp-ts Either<...> because, unlike try-catch, errors are
 * strongly typed with the Either contstruct, making it so the error contextual
 * data flows with inference through your program.
 */
export declare function createContextualError<Context extends Record<string, unknown>>(message: string, context: Context): ContextualError<Context>;
/**
 * Extract the left value from an Either.
 */
export declare function getLeft<A, B>(e: Either<A, B>): A | undefined;
/**
 * Extract the right value from an Either.
 */
export declare function getRight<A, B>(e: Either<A, B>): B | undefined;
/**
 * Extract the right value from an Either or throw.
 */
export declare function rightOrThrow<A, B>(x: Either<A, B>): B;
//# sourceMappingURL=utils.d.ts.map